import{createMemoryHistory,parsePath}from'history';import PropTypes from'prop-types';import React from'react';function h(a,b){if(!a)throw Error(b);}function l(a,b){if(!a){"undefined"!==typeof console&&console.warn(b);try{throw Error(b);}catch(c){}}}let m=React.createContext(null);m.displayName="Location";let n=React.createContext({outlet:null,params:Object.freeze({}),pathname:"",route:null});n.displayName="Route";
function p({children:a,initialEntries:b,initialIndex:c,timeout:e}){let d=React.useRef(null);null==d.current&&(d.current=createMemoryHistory({initialEntries:b,initialIndex:c}));return React.createElement(q,{children:a,history:d.current,timeout:e})}p.displayName="MemoryRouter";
p.propTypes={children:PropTypes.node,timeout:PropTypes.number,initialEntries:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string,state:PropTypes.object,key:PropTypes.string})])),initialIndex:PropTypes.number};
function r({to:a,replace:b,state:c}){let e=u(),d=React.useContext(m);null==d?h(!1,"<Navigate> may be used only in the context of a <Router> component."):void 0;l(!d.history.static,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");React.useEffect(()=>{e(a,{replace:b,state:c})});return null}r.displayName="Navigate";
r.propTypes={to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired,replace:PropTypes.bool,state:PropTypes.object};function v(){return w()}v.displayName="Outlet";v.propTypes={};function x({element:a=React.createElement(v,null)}){return a}x.displayName="Route";x.propTypes={children:PropTypes.node,element:PropTypes.element,path:PropTypes.string};let y=a=>a(),z=React.useTransition||(()=>[y,!1]);
function q({children:a=null,history:b,timeout:c=2E3}){let [e,d]=React.useState(b.location),[f,g]=z({timeoutMs:c});c=React.useRef(!0);React.useContext(m)?h(!1,"You cannot render a <Router> inside another <Router>. You never need more than one."):void 0;c.current&&(c.current=!1,b.listen(({location:b})=>{f(()=>{d(b)})}));return React.createElement(m.Provider,{children:a,value:{history:b,location:e,pending:g}})}q.displayName="Router";
q.propTypes={children:PropTypes.node,history:PropTypes.shape({action:PropTypes.string,location:PropTypes.object,push:PropTypes.func,replace:PropTypes.func,go:PropTypes.func,listen:PropTypes.func,block:PropTypes.func}),timeout:PropTypes.number};function A({basename:a="",caseSensitive:b=!1,children:c}){c=B(c);return C(c,a,b)}A.displayName="Routes";A.propTypes={basename:PropTypes.string,caseSensitive:PropTypes.bool,children:PropTypes.node};
function B(a){let b=[];React.Children.forEach(a,a=>{if(React.isValidElement(a)){var {children:c,path:d="/"}=a.props;if(a.type===React.Fragment)b.push.apply(b,B(c));else{a={path:d,element:a};var f=B(c);f.length&&(a.children=f);b.push(a)}}});return b}function D(){return React.useContext(m).location}
function u(){let {pathname:a}=React.useContext(n),b=React.useContext(m);null==b?h(!1,"useNavigate() may be used only in the context of a <Router> component."):void 0;let {history:c,pending:e}=b,d=React.useRef(!1);React.useEffect(()=>{d.current=!0});return React.useCallback((b,{replace:g,state:k}={})=>{d.current?"number"===typeof b?c.go(b):(b=E(b,a),c[g||e?"replace":"push"](b,k)):l(!1,"You should call navigate() in a useEffect, not when your component is first rendered.")},[c,a,e])}
function w(){return React.useContext(n).outlet}function F(a){let {pathname:b}=React.useContext(n);return React.useMemo(()=>E(a,b),[a,b])}let G,H;G={};H=(a,b,c)=>{b||G[a]||(G[a]=!0,l(!1,c))};
function C(a,b="",c=!1){let {params:e,pathname:d,route:f}=React.useContext(n);if(H){var g=f&&f.path;H(d,!f||f.path.endsWith("*"),`You rendered descendant <Routes> (or called \`useRoutes\`) at "${d}"`+` (under <Route path="${g}">) but the parent route path has no trailing "*".`+" This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\n"+`Please change the parent <Route path="${g}"> to <Route path="${g}/*">.`)}b=b?[d,b].join("/").replace(/\/\/+/g,
"/"):d;let k=D();return(g=React.useMemo(()=>I(a,k,b,c),[a,k,b,c]))?g.reduceRight((a,{params:c,pathname:d,route:f})=>React.createElement(n.Provider,{children:f.element,value:{outlet:a,params:Object.freeze({...e,...c}),pathname:[b,d].join("/").replace(/\/\/+/g,"/"),route:f}}),null):null}
function I(a,b,c="",e=!1){"string"===typeof b&&(b=parsePath(b));c=c.replace(/^\/+|\/+$/g,"");let d=b.pathname.slice(1);if(c)if(c===d)d="";else if(d.startsWith(c))d=d.slice(c.length).replace(/^\/+/,"");else return null;a=J(a);K(a);for(b=0;b<a.length;++b){let [f,g]=a[b];[c]=L(f,!0,e);if(c.test(d))return g.map((a,b)=>{b=g.slice(0,b+1).map(b=>b.path).join("/").replace(/\/\/+/g,"/");let [c,f]=L(b,!1,e);b=d.match(c);let k="/"+b[1],t=b.slice(2);return{params:f.reduce((b,a,c)=>{c=t[c];try{var e=decodeURIComponent(c.replace(/\+/g,
" "))}catch(N){l(!1,`The value for the URL param "${a}" will not be decoded because`+` the string "${c}" is a malformed URL segment. This is probably`+` due to a bad percent encoding (the error message was: ${N.message}).`),e=c}b[a]=e;return b},{}),pathname:k,route:a}})}return null}function J(a,b=[],c="",e=[],d=[]){a.forEach((a,g)=>{let f=[c,a.path].join("/").replace(/\/\/+/g,"/"),t=e.concat(a);g=d.concat(g);b.push([f,t,g]);a.children&&J(a.children,b,f,t,g)});return b}let M=/^:\w+$/,O=a=>"*"===a;
function P(a){a=a.split("/");let b=a.length;a.some(O)&&(b+=-2);return a.filter(b=>"*"!==b).reduce((b,a)=>b+(M.test(a)?2:""===a?1:10),b)}function K(a){let b=a.reduce((b,[a])=>{b[a]=P(a);return b},{});a.sort((a,e)=>{let [c,,f]=a;a=b[c];let [g,,k]=e;e=b[g];return a!==e?e-a:Q(f,k)})}function Q(a,b){return a.length===b.length&&a.slice(0,-1).every((a,e)=>a===b[e])?a[a.length-1]-b[b.length-1]:0}
function L(a,b,c){let e=[],d="^("+a.replace(/^\/+/,"").replace(/\*\//g,"").replace(/\/?\*?$/,"").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,(a,b)=>{e.push(b);return"([^\\/]+)"})+")";a.endsWith("*")?(a.endsWith("/*")&&(d+="\\/?"),e.push("*"),d+="(.*)"):b&&(d+="\\/?");b&&(d+="$");return[new RegExp(d,c?void 0:"i"),e]}
function R(a,b){let c=b.replace(/\/+$/,"").replace(/\/\/+/g,"/").split("/");a.replace(/\/\/+/g,"/").split("/").forEach(a=>{".."===a?1<c.length&&c.pop():"."!==a&&c.push(a)});return 1<c.length?c.join("/").replace(/\/\/+/g,"/"):"/"}function E(a,b="/"){let {pathname:c,search:e="",hash:d=""}="string"===typeof a?parsePath(a):a;return{pathname:c?c.startsWith("/")?R(c,"/"):R(c,b):b,search:e,hash:d}}
function generatePath(a,b={}){return a.replace(/:(\w+)/g,(a,e)=>b[e]||`:${e}`).replace(/\*$/,a=>b[a]||a)};function useBlocker(a,b=!0){let c=React.useContext(m);null==c?h(!1,"useBlocker() may be used only in the context of a <Router> component."):void 0;let {history:e}=c;React.useEffect(()=>{if(b){let b=e.block(c=>{a({...c,retry(){b();c.retry()}})});return b}},[e,b,a])};
function useHref(a){a=F(a);let b=React.useContext(m);null==b?h(!1,"useHref() may be used only in the context of a <Router> component."):void 0;return b.history.createHref(a)};function useMatch(a){let b=D();a=F(a);return b.pathname===a.pathname};function useParams(){return React.useContext(n).params};export{p as MemoryRouter,r as Navigate,v as Outlet,x as Route,q as Router,A as Routes,B as createRoutesFromChildren,generatePath,I as matchRoutes,E as resolveLocation,useBlocker,useHref,D as useLocation,useMatch,u as useNavigate,w as useOutlet,useParams,F as useResolvedLocation,C as useRoutes}
//# sourceMappingURL=react-router.development.js.map
