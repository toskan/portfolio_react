import{createMemoryHistory,parsePath}from'history';import PropTypes from'prop-types';import React from'react';function h(){h=Object.assign||function(a){for(var b=1;b<arguments.length;b++){var c=arguments[b],d;for(d in c)Object.prototype.hasOwnProperty.call(c,d)&&(a[d]=c[d])}return a};return h.apply(this,arguments)}var k="production"!==process.env.NODE_ENV?function(a){return Object.freeze(a)}:function(a){return a};function l(a,b){if(!a)throw Error(b);}function m(a,b){if(!a){"undefined"!==typeof console&&console.warn(b);try{throw Error(b);}catch(c){}}}var n=React.createContext(null);
"production"!==process.env.NODE_ENV&&(n.displayName="Location");var p=React.createContext({outlet:null,params:k({}),pathname:"",route:null});"production"!==process.env.NODE_ENV&&(p.displayName="Route");function q(a){var b=a.children,c=a.initialEntries,d=a.initialIndex;a=a.timeout;var e=React.useRef(null);null==e.current&&(e.current=createMemoryHistory({initialEntries:c,initialIndex:d}));return React.createElement(r,{children:b,history:e.current,timeout:a})}
"production"!==process.env.NODE_ENV&&(q.displayName="MemoryRouter",q.propTypes={children:PropTypes.node,timeout:PropTypes.number,initialEntries:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string,state:PropTypes.object,key:PropTypes.string})])),initialIndex:PropTypes.number});
function u(a){var b=a.to,c=a.replace,d=a.state,e=v();a=React.useContext(n);null==a?"production"!==process.env.NODE_ENV?l(!1,"<Navigate> may be used only in the context of a <Router> component."):l(!1):void 0;"production"!==process.env.NODE_ENV?m(!a.history.static,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."):void 0;React.useEffect(function(){e(b,
{replace:c,state:d})});return null}"production"!==process.env.NODE_ENV&&(u.displayName="Navigate",u.propTypes={to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired,replace:PropTypes.bool,state:PropTypes.object});function w(){return x()}"production"!==process.env.NODE_ENV&&(w.displayName="Outlet",w.propTypes={});function y(a){a=a.element;return void 0===a?React.createElement(w,null):a}
"production"!==process.env.NODE_ENV&&(y.displayName="Route",y.propTypes={children:PropTypes.node,element:PropTypes.element,path:PropTypes.string});function z(a){return a()}var A=React.useTransition||function(){return[z,!1]};
function r(a){var b=a.children;b=void 0===b?null:b;var c=a.history;a=a.timeout;var d=void 0===a?2E3:a,e=React.useState(c.location);a=e[0];var f=e[1];d=A({timeoutMs:d});var g=d[0];d=d[1];e=React.useRef(!0);React.useContext(n)?"production"!==process.env.NODE_ENV?l(!1,"You cannot render a <Router> inside another <Router>. You never need more than one."):l(!1):void 0;e.current&&(e.current=!1,c.listen(function(a){var b=a.location;g(function(){f(b)})}));return React.createElement(n.Provider,{children:b,
value:{history:c,location:a,pending:d}})}"production"!==process.env.NODE_ENV&&(r.displayName="Router",r.propTypes={children:PropTypes.node,history:PropTypes.shape({action:PropTypes.string,location:PropTypes.object,push:PropTypes.func,replace:PropTypes.func,go:PropTypes.func,listen:PropTypes.func,block:PropTypes.func}),timeout:PropTypes.number});function B(a){var b=a.basename;b=void 0===b?"":b;var c=a.caseSensitive;c=void 0===c?!1:c;a=C(a.children);return D(a,b,c)}
"production"!==process.env.NODE_ENV&&(B.displayName="Routes",B.propTypes={basename:PropTypes.string,caseSensitive:PropTypes.bool,children:PropTypes.node});function C(a){var b=[];React.Children.forEach(a,function(a){if(React.isValidElement(a)){var c=a.props,e=c.children;c=c.path;c=void 0===c?"/":c;a.type===React.Fragment?b.push.apply(b,C(e)):(a={path:c,element:a},e=C(e),e.length&&(a.children=e),b.push(a))}});return b}function E(){return React.useContext(n).location}
function v(){var a=React.useContext(p).pathname,b=React.useContext(n);null==b?"production"!==process.env.NODE_ENV?l(!1,"useNavigate() may be used only in the context of a <Router> component."):l(!1):void 0;var c=b.history,d=b.pending,e=React.useRef(!1);React.useEffect(function(){e.current=!0});return React.useCallback(function(b,g){var f=void 0===g?{}:g;g=f.replace;f=f.state;e.current?"number"===typeof b?c.go(b):(b=F(b,a),c[g||d?"replace":"push"](b,f)):"production"!==process.env.NODE_ENV?m(!1,"You should call navigate() in a useEffect, not when your component is first rendered."):
void 0},[c,a,d])}function x(){return React.useContext(p).outlet}function G(a){var b=React.useContext(p).pathname;return React.useMemo(function(){return F(a,b)},[a,b])}var I,J;"production"!==process.env.NODE_ENV&&(I={},J=function(a,b,c){b||I[a]||(I[a]=!0,"production"!==process.env.NODE_ENV?m(!1,c):void 0)});
function D(a,b,c){void 0===b&&(b="");void 0===c&&(c=!1);var d=React.useContext(p),e=d.params,f=d.pathname;d=d.route;if(J){var g=d&&d.path;J(f,!d||d.path.endsWith("*"),'You rendered descendant <Routes> (or called `useRoutes`) at "'+f+'" (under <Route path="'+(g+'">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="')+(g+'"> to <Route path="'+g+
'/*">.'))}b=b?K([f,b]):f;var t=E();return(f=React.useMemo(function(){return L(a,t,b,c)},[a,t,b,c]))?f.reduceRight(function(a,c){var d=c.pathname,f=c.route;return React.createElement(p.Provider,{children:f.element,value:{outlet:a,params:k(h({},e,{},c.params)),pathname:K([b,d]),route:f}})},null):null}
function L(a,b,c,d){function e(a){a=g[a];var b=a[1];if(M(a[0],!0,d)[0].test(f))return{v:b.map(function(a,c){c=b.slice(0,c+1);c=K(c.map(function(a){return a.path}));var e=M(c,!1,d);c=e[1];e=f.match(e[0]);var g="/"+e[1],t=e.slice(2);return{params:c.reduce(function(a,b,c){c=t[c];try{var d=decodeURIComponent(c.replace(/\+/g," "))}catch(Q){"production"!==process.env.NODE_ENV?m(!1,'The value for the URL param "'+b+'" will not be decoded because the string "'+(c+'" is a malformed URL segment. This is probably due to a bad percent encoding (the error message was: ')+
(Q.message+").")):void 0,d=c}a[b]=d;return a},{}),pathname:g,route:a}})}}void 0===c&&(c="");void 0===d&&(d=!1);"string"===typeof b&&(b=parsePath(b));c=c.replace(/^\/+|\/+$/g,"");var f=b.pathname.slice(1);if(c)if(c===f)f="";else if(f.startsWith(c))f=f.slice(c.length).replace(/^\/+/,"");else return null;var g=N(a);O(g);for(a=0;a<g.length;++a)if(b=e(a),"object"===typeof b)return b.v;return null}
function N(a,b,c,d,e){void 0===b&&(b=[]);void 0===c&&(c="");void 0===d&&(d=[]);void 0===e&&(e=[]);a.forEach(function(a,g){var f=K([c,a.path]),H=d.concat(a);g=e.concat(g);b.push([f,H,g]);a.children&&N(a.children,b,f,H,g)});return b}var P=/^:\w+$/,R=2,S=1,T=10,U=-2;function V(a){return"*"===a}function W(a){a=a.split("/");var b=a.length;a.some(V)&&(b+=U);return a.filter(function(a){return!V(a)}).reduce(function(a,b){return a+(P.test(b)?R:""===b?S:T)},b)}
function O(a){var b=a.reduce(function(a,b){b=b[0];a[b]=W(b);return a},{});a.sort(function(a,d){var c=a[2];a=b[a[0]];var f=d[2];d=b[d[0]];return a!==d?d-a:X(c,f)})}function X(a,b){return a.length===b.length&&a.slice(0,-1).every(function(a,d){return a===b[d]})?a[a.length-1]-b[b.length-1]:0}
function M(a,b,c){var d=[],e="^("+a.replace(/^\/+/,"").replace(/\*\//g,"").replace(/\/?\*?$/,"").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,function(a,b){d.push(b);return"([^\\/]+)"})+")";a.endsWith("*")?(a.endsWith("/*")&&(e+="\\/?"),d.push("*"),e+="(.*)"):b&&(e+="\\/?");b&&(e+="$");return[new RegExp(e,c?void 0:"i"),d]}function K(a){return a.join("/").replace(/\/\/+/g,"/")}
function Y(a,b){var c=b.replace(/\/+$/,"").replace(/\/\/+/g,"/").split("/");a.replace(/\/\/+/g,"/").split("/").forEach(function(a){".."===a?1<c.length&&c.pop():"."!==a&&c.push(a)});return 1<c.length?K(c):"/"}function F(a,b){void 0===b&&(b="/");var c="string"===typeof a?parsePath(a):a;a=c.pathname;var d=c.search;d=void 0===d?"":d;c=c.hash;c=void 0===c?"":c;return{pathname:a?a.startsWith("/")?Y(a,"/"):Y(a,b):b,search:d,hash:c}}
function generatePath(a,b){void 0===b&&(b={});return a.replace(/:(\w+)/g,function(a,d){return b[d]||":"+d}).replace(/\*$/,function(a){return b[a]||a})};
function useBlocker(a,b){void 0===b&&(b=!0);var c=React.useContext(n);null==c?"production"!==process.env.NODE_ENV?l(!1,"useBlocker() may be used only in the context of a <Router> component."):l(!1):void 0;var d=c.history;React.useEffect(function(){if(b){var c=d.block(function(b){var d=h({},b,{retry:function(){c();b.retry()}});a(d)});return c}},[d,b,a])};
function useHref(a){a=G(a);var b=React.useContext(n);null==b?"production"!==process.env.NODE_ENV?l(!1,"useHref() may be used only in the context of a <Router> component."):l(!1):void 0;return b.history.createHref(a)};function useMatch(a){var b=E();a=G(a);return b.pathname===a.pathname};function useParams(){return React.useContext(p).params};export{q as MemoryRouter,u as Navigate,w as Outlet,y as Route,r as Router,B as Routes,C as createRoutesFromChildren,generatePath,L as matchRoutes,F as resolveLocation,useBlocker,useHref,E as useLocation,useMatch,v as useNavigate,x as useOutlet,useParams,G as useResolvedLocation,D as useRoutes}
//# sourceMappingURL=react-router.js.map
