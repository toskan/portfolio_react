{"version":3,"file":"react-router.js","sources":["../../packages/react-router/index.js"],"sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { createMemoryHistory, parsePath } from 'history';\n\nconst readOnly = __DEV__ ? obj => Object.freeze(obj) : obj => obj;\n\nfunction invariant(cond, message) {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONTEXT\n///////////////////////////////////////////////////////////////////////////////\n\nconst LocationContext = React.createContext(null);\n\nif (__DEV__) {\n  LocationContext.displayName = 'Location';\n}\n\nconst RouteContext = React.createContext({\n  outlet: null,\n  params: readOnly({}),\n  pathname: '',\n  route: null\n});\n\nif (__DEV__) {\n  RouteContext.displayName = 'Route';\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * A <Router> that stores all entries in memory.\n */\nexport function MemoryRouter({\n  children,\n  initialEntries,\n  initialIndex,\n  timeout\n}) {\n  let historyRef = React.useRef(null);\n\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  return (\n    <Router\n      children={children}\n      history={historyRef.current}\n      timeout={timeout}\n    />\n  );\n}\n\nif (__DEV__) {\n  MemoryRouter.displayName = 'MemoryRouter';\n  MemoryRouter.propTypes = {\n    children: PropTypes.node,\n    timeout: PropTypes.number,\n    initialEntries: PropTypes.arrayOf(\n      PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.shape({\n          pathname: PropTypes.string,\n          search: PropTypes.string,\n          hash: PropTypes.string,\n          state: PropTypes.object,\n          key: PropTypes.string\n        })\n      ])\n    ),\n    initialIndex: PropTypes.number\n  };\n}\n\n/**\n * Navigate programmatically using a component.\n */\nexport function Navigate({ to, replace, state }) {\n  let navigate = useNavigate();\n\n  let locationContext = React.useContext(LocationContext);\n  invariant(\n    locationContext != null,\n    // TODO: This error is probably because they somehow have\n    // 2 versions of the router loaded. We can help them understand\n    // how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !locationContext.history.static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  React.useEffect(() => {\n    navigate(to, { replace, state });\n  });\n\n  return null;\n}\n\nif (__DEV__) {\n  Navigate.displayName = 'Navigate';\n  Navigate.propTypes = {\n    to: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.shape({\n        pathname: PropTypes.string,\n        search: PropTypes.string,\n        hash: PropTypes.string\n      })\n    ]).isRequired,\n    replace: PropTypes.bool,\n    state: PropTypes.object\n  };\n}\n\n/**\n * Renders the child route's element, if there is one.\n */\nexport function Outlet() {\n  return useOutlet();\n}\n\nif (__DEV__) {\n  Outlet.displayName = 'Outlet';\n  Outlet.propTypes = {};\n}\n\n/**\n * Used in a route config to render an element.\n */\nexport function Route({ element = <Outlet /> }) {\n  return element;\n}\n\nif (__DEV__) {\n  Route.displayName = 'Route';\n  Route.propTypes = {\n    children: PropTypes.node,\n    element: PropTypes.element,\n    path: PropTypes.string\n  };\n}\n\n// TODO: Remove once React.useTransition is stable.\nconst startTransition = tx => tx();\nconst useTransition = React.useTransition || (() => [startTransition, false]);\n\n/**\n * The root context provider. There should be only one of these in a given app.\n */\nexport function Router({ children = null, history, timeout = 2000 }) {\n  let [location, setLocation] = React.useState(history.location);\n  let [startTransition, pending] = useTransition({ timeoutMs: timeout });\n  let shouldListenRef = React.useRef(true);\n\n  invariant(\n    !React.useContext(LocationContext),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You never need more than one.`\n  );\n\n  if (shouldListenRef.current) {\n    shouldListenRef.current = false;\n    history.listen(({ location }) => {\n      startTransition(() => {\n        setLocation(location);\n      });\n    });\n  }\n\n  return (\n    <LocationContext.Provider\n      children={children}\n      value={{ history, location, pending }}\n    />\n  );\n}\n\nif (__DEV__) {\n  Router.displayName = 'Router';\n  Router.propTypes = {\n    children: PropTypes.node,\n    history: PropTypes.shape({\n      action: PropTypes.string,\n      location: PropTypes.object,\n      push: PropTypes.func,\n      replace: PropTypes.func,\n      go: PropTypes.func,\n      listen: PropTypes.func,\n      block: PropTypes.func\n    }),\n    timeout: PropTypes.number\n  };\n}\n\n/**\n * A wrapper for useRoutes that treats its children as route and/or redirect\n * objects.\n */\nexport function Routes({ basename = '', caseSensitive = false, children }) {\n  let routes = createRoutesFromChildren(children);\n  return useRoutes(routes, basename, caseSensitive);\n}\n\nif (__DEV__) {\n  Routes.displayName = 'Routes';\n  Routes.propTypes = {\n    basename: PropTypes.string,\n    caseSensitive: PropTypes.bool,\n    children: PropTypes.node\n  };\n}\n\n/**\n * Utility function that creates a routes config object from a React\n * \"children\" object, which is usually either a React element or an\n * array of elements.\n */\nexport function createRoutesFromChildren(children) {\n  let routes = [];\n\n  React.Children.forEach(children, element => {\n    // Ignore non-elements. This allows people to more\n    // easily inline conditionals in their route config.\n    if (!React.isValidElement(element)) return;\n\n    let { children, path = '/' } = element.props;\n\n    // Transparently support React.Fragment and its children.\n    if (element.type === React.Fragment) {\n      routes.push.apply(routes, createRoutesFromChildren(children));\n      return;\n    }\n\n    let route = { path, element };\n    let childRoutes = createRoutesFromChildren(children);\n    if (childRoutes.length) {\n      route.children = childRoutes;\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Blocks all navigation attempts. This is useful for preventing the page from\n * changing until some condition is met, like saving form data.\n */\nexport function useBlocker(blocker, when = true) {\n  let locationContext = React.useContext(LocationContext);\n  invariant(\n    locationContext != null,\n    // TODO: This error is probably because they somehow have\n    // 2 versions of the router loaded. We can help them understand\n    // how to avoid that.\n    `useBlocker() may be used only in the context of a <Router> component.`\n  );\n  let { history } = locationContext;\n\n  React.useEffect(() => {\n    if (when) {\n      let unblock = history.block(tx => {\n        let autoUnblockingTx = {\n          ...tx,\n          retry() {\n            // Automatically unblock the transition so it can\n            // play all the way through before retrying it.\n            // TODO: Figure out how to re-enable this block if the\n            // transition is cancelled for some reason.\n            unblock();\n            tx.retry();\n          }\n        };\n\n        blocker(autoUnblockingTx);\n      });\n\n      return unblock;\n    }\n  }, [history, when, blocker]);\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n */\nexport function useHref(to) {\n  let resolvedLocation = useResolvedLocation(to);\n\n  let locationContext = React.useContext(LocationContext);\n  invariant(\n    locationContext != null,\n    // TODO: This error is probably because they somehow have\n    // 2 versions of the router loaded. We can help them understand\n    // how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  return locationContext.history.createHref(resolvedLocation);\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * NOTE: If you're using this it may mean you're doing some of your own \"routing\"\n * in your app, and we'd like to know what your use case is. We may be able to\n * provide something higher-level to better suit your needs.\n */\nexport function useLocation() {\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n */\nexport function useMatch(to) {\n  let location = useLocation();\n  let resolvedLocation = useResolvedLocation(to);\n  // TODO: Try to match search + hash as well\n  return location.pathname === resolvedLocation.pathname;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n */\nexport function useNavigate() {\n  let { pathname } = React.useContext(RouteContext);\n\n  let locationContext = React.useContext(LocationContext);\n  invariant(\n    locationContext != null,\n    // TODO: This error is probably because they somehow have\n    // 2 versions of the router loaded. We can help them understand\n    // how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n  let { history, pending } = locationContext;\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate = React.useCallback(\n    (to, { replace, state } = {}) => {\n      if (activeRef.current) {\n        if (typeof to === 'number') {\n          history.go(to);\n        } else {\n          let relativeTo = resolveLocation(to, pathname);\n          // If we are pending transition, use REPLACE instead of PUSH.\n          // This will prevent URLs that we started navigating to but\n          // never fully loaded from appearing in the history stack.\n          let method = !!replace || pending ? 'replace' : 'push';\n          history[method](relativeTo, state);\n        }\n      } else {\n        warning(\n          false,\n          `You should call navigate() in a useEffect, not when ` +\n            `your component is first rendered.`\n        );\n      }\n    },\n    [history, pathname, pending]\n  );\n\n  return navigate;\n}\n\n/**\n * Returns the outlet element at this level of the route hierarchy. Used to\n * render child routes.\n */\nexport function useOutlet() {\n  return React.useContext(RouteContext).outlet;\n}\n\n/**\n * Returns a hash of the dynamic params that were matched in the route path.\n * This is useful for using ids embedded in the URL to fetch data, but we\n * eventually want to provide something at a higher level for this.\n */\nexport function useParams() {\n  return React.useContext(RouteContext).params;\n}\n\n/**\n * Returns a fully-resolved location object relative to the current location.\n */\nexport function useResolvedLocation(to) {\n  let { pathname } = React.useContext(RouteContext);\n  return React.useMemo(() => resolveLocation(to, pathname), [to, pathname]);\n}\n\nlet missingTrailingSplatWarnings, warnAboutMissingTrailingSplatAt;\nif (__DEV__) {\n  missingTrailingSplatWarnings = {};\n  warnAboutMissingTrailingSplatAt = (pathname, cond, message) => {\n    if (!cond && !missingTrailingSplatWarnings[pathname]) {\n      missingTrailingSplatWarnings[pathname] = true;\n      warning(false, message);\n    }\n  };\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * Route objects may take one of 2 forms:\n *\n * - { path, element, children }\n * - { path, redirectTo }\n *\n * We should probably write this up in TypeScript instead of in a comment. In\n * fact, what am I even doing here. Nobody is ever going to read this.\n */\nexport function useRoutes(routes, basename = '', caseSensitive = false) {\n  let {\n    params: parentParams,\n    pathname: parentPathname,\n    route: parentRoute\n  } = React.useContext(RouteContext);\n\n  if (warnAboutMissingTrailingSplatAt) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since\n    // we cannot even give the warning unless they land at the parent route.\n    let parentPath = parentRoute && parentRoute.path;\n    warnAboutMissingTrailingSplatAt(\n      parentPathname,\n      !parentRoute || parentRoute.path.endsWith('*'),\n      `You rendered descendant <Routes> (or called \\`useRoutes\\`) at \"${parentPathname}\"` +\n        ` (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\".` +\n        ` This means if you navigate deeper, the parent won't match anymore and therefore` +\n        ` the child routes will never render.` +\n        `\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath}/*\">.`\n    );\n  }\n\n  basename = basename ? joinPaths([parentPathname, basename]) : parentPathname;\n\n  let location = useLocation();\n  let matches = React.useMemo(\n    () => matchRoutes(routes, location, basename, caseSensitive),\n    [routes, location, basename, caseSensitive]\n  );\n\n  if (!matches) {\n    // TODO: Warn about nothing matching, suggest using a catch-all route.\n    return null;\n  }\n\n  // TODO: Initiate preload sequence here.\n\n  // Otherwise render an element.\n  let element = matches.reduceRight((outlet, { params, pathname, route }) => {\n    return (\n      <RouteContext.Provider\n        children={route.element}\n        value={{\n          outlet,\n          params: readOnly({ ...parentParams, ...params }),\n          pathname: joinPaths([basename, pathname]),\n          route\n        }}\n      />\n    );\n  }, null);\n\n  return element;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Matches the given routes to a location and returns the match data.\n */\nexport function matchRoutes(\n  routes,\n  location,\n  basename = '',\n  caseSensitive = false\n) {\n  if (typeof location === 'string') {\n    location = parsePath(location);\n  }\n\n  // TODO: Validate location\n  // - it should have a pathname\n  let base = basename.replace(/^\\/+|\\/+$/g, '');\n  let target = location.pathname.slice(1);\n\n  if (base) {\n    if (base === target) {\n      target = '';\n    } else if (target.startsWith(base)) {\n      target = target.slice(base.length).replace(/^\\/+/, '');\n    } else {\n      return null;\n    }\n  }\n\n  let flattenedRoutes = flattenRoutes(routes);\n\n  // TODO: Validate the routes config\n  // - routes should all have paths and elements\n  // - redirects should have a redirectTo\n  // - redirects should not have children\n  // - warn about unreachable routes\n\n  rankFlattenedRoutes(flattenedRoutes);\n\n  for (let i = 0; i < flattenedRoutes.length; ++i) {\n    let [path, flatRoutes] = flattenedRoutes[i];\n\n    // TODO: Match on search, state too\n    let [matcher] = compilePath(path, /* end */ true, caseSensitive);\n\n    if (matcher.test(target)) {\n      return flatRoutes.map((route, index) => {\n        let routes = flatRoutes.slice(0, index + 1);\n        let path = joinPaths(routes.map(r => r.path));\n        let [matcher, keys] = compilePath(path, /* end */ false, caseSensitive);\n        let match = target.match(matcher);\n        let pathname = '/' + match[1];\n        let values = match.slice(2);\n        let params = keys.reduce((memo, key, index) => {\n          memo[key] = safelyDecodeURIComponent(values[index], key);\n          return memo;\n        }, {});\n\n        return { params, pathname, route };\n      });\n    }\n  }\n\n  return null;\n}\n\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value.replace(/\\+/g, ' '));\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (the error message was: ${error.message}).`\n    );\n\n    return value;\n  }\n}\n\nfunction flattenRoutes(\n  routes,\n  flattenedRoutes = [],\n  parentPath = '',\n  parentRoutes = [],\n  parentIndexes = []\n) {\n  routes.forEach((route, index) => {\n    let path = joinPaths([parentPath, route.path]);\n    let routes = parentRoutes.concat(route);\n    let indexes = parentIndexes.concat(index);\n\n    flattenedRoutes.push([path, routes, indexes]);\n\n    if (route.children) {\n      flattenRoutes(route.children, flattenedRoutes, path, routes, indexes);\n    }\n  });\n\n  return flattenedRoutes;\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === '*';\n\nfunction computeScore(path) {\n  let segments = path.split('/');\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  return segments\n    .filter(s => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === ''\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction rankFlattenedRoutes(flattenedRoutes) {\n  let pathScores = flattenedRoutes.reduce((memo, [path]) => {\n    memo[path] = computeScore(path);\n    return memo;\n  }, {});\n\n  flattenedRoutes.sort((a, b) => {\n    let [aPath, , aIndexes] = a;\n    let aScore = pathScores[aPath];\n\n    let [bPath, , bIndexes] = b;\n    let bScore = pathScores[bPath];\n\n    return aScore !== bScore\n      ? bScore - aScore // Higher score first\n      : compareIndexes(aIndexes, bIndexes);\n  });\n}\n\nfunction compareIndexes(a, b) {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? a[a.length - 1] - b[b.length - 1] // Earlier siblings come first\n    : 0; // It doesn't make sense to rank non-siblings by index, so they sort equal\n}\n\nfunction compilePath(path, end, caseSensitive) {\n  let keys = [];\n  let pattern =\n    '^(' +\n    path\n      .replace(/^\\/+/, '') // Ignore leading /\n      .replace(/\\*\\//g, '') // Ignore */ (from paths nested under a *)\n      .replace(/\\/?\\*?$/, '') // Ignore trailing /*, we'll handle it below\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, '\\\\$&') // Escape special regex chars\n      .replace(/:(\\w+)/g, (_, key) => {\n        keys.push(key);\n        return '([^\\\\/]+)';\n      }) +\n    ')';\n\n  if (path.endsWith('*')) {\n    if (path.endsWith('/*')) {\n      pattern += '\\\\/?'; // Don't include the / in params['*']\n    }\n    keys.push('*');\n    pattern += '(.*)';\n  } else if (end) {\n    pattern += '\\\\/?';\n  }\n\n  if (end) pattern += '$';\n\n  let flags = caseSensitive ? undefined : 'i';\n  let matcher = new RegExp(pattern, flags);\n\n  return [matcher, keys];\n}\n\nconst trimTrailingSlashes = path => path.replace(/\\/+$/, '');\nconst normalizeSlashes = path => path.replace(/\\/\\/+/g, '/');\nconst joinPaths = paths => normalizeSlashes(paths.join('/'));\nconst splitPath = path => normalizeSlashes(path).split('/');\n\nfunction resolvePathname(toPathname, fromPathname) {\n  let segments = splitPath(trimTrailingSlashes(fromPathname));\n  let relativeSegments = splitPath(toPathname);\n\n  relativeSegments.forEach(segment => {\n    if (segment === '..') {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== '.') {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? joinPaths(segments) : '/';\n}\n\n/**\n * Returns a fully resolve location object relative to the given pathname.\n */\nexport function resolveLocation(to, fromPathname = '/') {\n  let { pathname: toPathname, search = '', hash = '' } =\n    typeof to === 'string' ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith('/')\n      ? resolvePathname(toPathname, '/')\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return { pathname, search, hash };\n}\n\n/**\n * Creates a path with params interpolated.\n */\nexport function generatePath(pathname, params = {}) {\n  return pathname\n    .replace(/:(\\w+)/g, (_, key) => params[key] || `:${key}`)\n    .replace(/\\*$/, splat => params[splat] || splat);\n}\n"],"names":["readOnly","process","env","NODE_ENV","obj","Object","invariant","cond","message","Error","warning","console","e","LocationContext","React","RouteContext","outlet","params","pathname","route","MemoryRouter","children","initialEntries","initialIndex","timeout","historyRef","createMemoryHistory","createElement","Router","history","PropTypes","search","hash","state","key","Navigate","to","replace","navigate","useNavigate","locationContext","Outlet","useOutlet","Route","element","path","startTransition","tx","useTransition","location","setLocation","timeoutMs","pending","shouldListenRef","Provider","value","action","push","go","listen","block","Routes","basename","caseSensitive","routes","createRoutesFromChildren","useRoutes","childRoutes","useLocation","activeRef","relativeTo","resolveLocation","method","useResolvedLocation","missingTrailingSplatWarnings","warnAboutMissingTrailingSplatAt","parentParams","parentPathname","parentRoute","parentPath","joinPaths","matches","matchRoutes","i","flattenedRoutes","flatRoutes","compilePath","matcher","target","index","r","keys","match","values","memo","decodeURIComponent","error","safelyDecodeURIComponent","parsePath","base","flattenRoutes","rankFlattenedRoutes","parentRoutes","parentIndexes","indexes","paramRe","dynamicSegmentValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","s","computeScore","segments","initialScore","score","segment","pathScores","a","b","aIndexes","aScore","bIndexes","bScore","compareIndexes","siblings","n","end","pattern","_","RegExp","undefined","paths","resolvePathname","toPathname","fromPathname","normalizeSlashes","relativeSegments","generatePath","splat","useBlocker","blocker","when","unblock","autoUnblockingTx","retry","useHref","resolvedLocation","useMatch","useParams"],"mappings":"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"}