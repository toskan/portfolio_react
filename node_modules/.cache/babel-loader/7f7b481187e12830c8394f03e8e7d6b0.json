{"ast":null,"code":"import { createMemoryHistory, parsePath } from 'history';\nimport PropTypes from 'prop-types';\nimport React from 'react';\n\nfunction h() {\n  h = Object.assign || function (a) {\n    for (var b = 1; b < arguments.length; b++) {\n      var c = arguments[b],\n          d;\n\n      for (d in c) {\n        Object.prototype.hasOwnProperty.call(c, d) && (a[d] = c[d]);\n      }\n    }\n\n    return a;\n  };\n\n  return h.apply(this, arguments);\n}\n\nvar k = \"production\" !== process.env.NODE_ENV ? function (a) {\n  return Object.freeze(a);\n} : function (a) {\n  return a;\n};\n\nfunction l(a, b) {\n  if (!a) throw Error(b);\n}\n\nfunction m(a, b) {\n  if (!a) {\n    \"undefined\" !== typeof console && console.warn(b);\n\n    try {\n      throw Error(b);\n    } catch (c) {}\n  }\n}\n\nvar n = React.createContext(null);\n\"production\" !== process.env.NODE_ENV && (n.displayName = \"Location\");\nvar p = React.createContext({\n  outlet: null,\n  params: k({}),\n  pathname: \"\",\n  route: null\n});\n\"production\" !== process.env.NODE_ENV && (p.displayName = \"Route\");\n\nfunction q(a) {\n  var b = a.children,\n      c = a.initialEntries,\n      d = a.initialIndex;\n  a = a.timeout;\n  var e = React.useRef(null);\n  null == e.current && (e.current = createMemoryHistory({\n    initialEntries: c,\n    initialIndex: d\n  }));\n  return React.createElement(r, {\n    children: b,\n    history: e.current,\n    timeout: a\n  });\n}\n\n\"production\" !== process.env.NODE_ENV && (q.displayName = \"MemoryRouter\", q.propTypes = {\n  children: PropTypes.node,\n  timeout: PropTypes.number,\n  initialEntries: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string,\n    state: PropTypes.object,\n    key: PropTypes.string\n  })])),\n  initialIndex: PropTypes.number\n});\n\nfunction u(a) {\n  var b = a.to,\n      c = a.replace,\n      d = a.state,\n      e = v();\n  a = React.useContext(n);\n  null == a ? \"production\" !== process.env.NODE_ENV ? l(!1, \"<Navigate> may be used only in the context of a <Router> component.\") : l(!1) : void 0;\n  \"production\" !== process.env.NODE_ENV ? m(!a.history.static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.\") : void 0;\n  React.useEffect(function () {\n    e(b, {\n      replace: c,\n      state: d\n    });\n  });\n  return null;\n}\n\n\"production\" !== process.env.NODE_ENV && (u.displayName = \"Navigate\", u.propTypes = {\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string\n  })]).isRequired,\n  replace: PropTypes.bool,\n  state: PropTypes.object\n});\n\nfunction w() {\n  return x();\n}\n\n\"production\" !== process.env.NODE_ENV && (w.displayName = \"Outlet\", w.propTypes = {});\n\nfunction y(a) {\n  a = a.element;\n  return void 0 === a ? React.createElement(w, null) : a;\n}\n\n\"production\" !== process.env.NODE_ENV && (y.displayName = \"Route\", y.propTypes = {\n  children: PropTypes.node,\n  element: PropTypes.element,\n  path: PropTypes.string\n});\n\nfunction z(a) {\n  return a();\n}\n\nvar A = React.useTransition || function () {\n  return [z, !1];\n};\n\nfunction r(a) {\n  var b = a.children;\n  b = void 0 === b ? null : b;\n  var c = a.history;\n  a = a.timeout;\n  var d = void 0 === a ? 2E3 : a,\n      e = React.useState(c.location);\n  a = e[0];\n  var f = e[1];\n  d = A({\n    timeoutMs: d\n  });\n  var g = d[0];\n  d = d[1];\n  e = React.useRef(!0);\n  React.useContext(n) ? \"production\" !== process.env.NODE_ENV ? l(!1, \"You cannot render a <Router> inside another <Router>. You never need more than one.\") : l(!1) : void 0;\n  e.current && (e.current = !1, c.listen(function (a) {\n    var b = a.location;\n    g(function () {\n      f(b);\n    });\n  }));\n  return React.createElement(n.Provider, {\n    children: b,\n    value: {\n      history: c,\n      location: a,\n      pending: d\n    }\n  });\n}\n\n\"production\" !== process.env.NODE_ENV && (r.displayName = \"Router\", r.propTypes = {\n  children: PropTypes.node,\n  history: PropTypes.shape({\n    action: PropTypes.string,\n    location: PropTypes.object,\n    push: PropTypes.func,\n    replace: PropTypes.func,\n    go: PropTypes.func,\n    listen: PropTypes.func,\n    block: PropTypes.func\n  }),\n  timeout: PropTypes.number\n});\n\nfunction B(a) {\n  var b = a.basename;\n  b = void 0 === b ? \"\" : b;\n  var c = a.caseSensitive;\n  c = void 0 === c ? !1 : c;\n  a = C(a.children);\n  return D(a, b, c);\n}\n\n\"production\" !== process.env.NODE_ENV && (B.displayName = \"Routes\", B.propTypes = {\n  basename: PropTypes.string,\n  caseSensitive: PropTypes.bool,\n  children: PropTypes.node\n});\n\nfunction C(a) {\n  var b = [];\n  React.Children.forEach(a, function (a) {\n    if (React.isValidElement(a)) {\n      var c = a.props,\n          e = c.children;\n      c = c.path;\n      c = void 0 === c ? \"/\" : c;\n      a.type === React.Fragment ? b.push.apply(b, C(e)) : (a = {\n        path: c,\n        element: a\n      }, e = C(e), e.length && (a.children = e), b.push(a));\n    }\n  });\n  return b;\n}\n\nfunction E() {\n  return React.useContext(n).location;\n}\n\nfunction v() {\n  var a = React.useContext(p).pathname,\n      b = React.useContext(n);\n  null == b ? \"production\" !== process.env.NODE_ENV ? l(!1, \"useNavigate() may be used only in the context of a <Router> component.\") : l(!1) : void 0;\n  var c = b.history,\n      d = b.pending,\n      e = React.useRef(!1);\n  React.useEffect(function () {\n    e.current = !0;\n  });\n  return React.useCallback(function (b, g) {\n    var f = void 0 === g ? {} : g;\n    g = f.replace;\n    f = f.state;\n    e.current ? \"number\" === typeof b ? c.go(b) : (b = F(b, a), c[g || d ? \"replace\" : \"push\"](b, f)) : \"production\" !== process.env.NODE_ENV ? m(!1, \"You should call navigate() in a useEffect, not when your component is first rendered.\") : void 0;\n  }, [c, a, d]);\n}\n\nfunction x() {\n  return React.useContext(p).outlet;\n}\n\nfunction G(a) {\n  var b = React.useContext(p).pathname;\n  return React.useMemo(function () {\n    return F(a, b);\n  }, [a, b]);\n}\n\nvar I, J;\n\"production\" !== process.env.NODE_ENV && (I = {}, J = function J(a, b, c) {\n  b || I[a] || (I[a] = !0, \"production\" !== process.env.NODE_ENV ? m(!1, c) : void 0);\n});\n\nfunction D(a, b, c) {\n  void 0 === b && (b = \"\");\n  void 0 === c && (c = !1);\n  var d = React.useContext(p),\n      e = d.params,\n      f = d.pathname;\n  d = d.route;\n\n  if (J) {\n    var g = d && d.path;\n    J(f, !d || d.path.endsWith(\"*\"), 'You rendered descendant <Routes> (or called `useRoutes`) at \"' + f + '\" (under <Route path=\"' + (g + '\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won\\'t match anymore and therefore the child routes will never render.\\n\\nPlease change the parent <Route path=\"') + (g + '\"> to <Route path=\"' + g + '/*\">.'));\n  }\n\n  b = b ? K([f, b]) : f;\n  var t = E();\n  return (f = React.useMemo(function () {\n    return L(a, t, b, c);\n  }, [a, t, b, c])) ? f.reduceRight(function (a, c) {\n    var d = c.pathname,\n        f = c.route;\n    return React.createElement(p.Provider, {\n      children: f.element,\n      value: {\n        outlet: a,\n        params: k(h({}, e, {}, c.params)),\n        pathname: K([b, d]),\n        route: f\n      }\n    });\n  }, null) : null;\n}\n\nfunction L(a, b, c, d) {\n  function e(a) {\n    a = g[a];\n    var b = a[1];\n    if (M(a[0], !0, d)[0].test(f)) return {\n      v: b.map(function (a, c) {\n        c = b.slice(0, c + 1);\n        c = K(c.map(function (a) {\n          return a.path;\n        }));\n        var e = M(c, !1, d);\n        c = e[1];\n        e = f.match(e[0]);\n        var g = \"/\" + e[1],\n            t = e.slice(2);\n        return {\n          params: c.reduce(function (a, b, c) {\n            c = t[c];\n\n            try {\n              var d = decodeURIComponent(c.replace(/\\+/g, \" \"));\n            } catch (Q) {\n              \"production\" !== process.env.NODE_ENV ? m(!1, 'The value for the URL param \"' + b + '\" will not be decoded because the string \"' + (c + '\" is a malformed URL segment. This is probably due to a bad percent encoding (the error message was: ') + (Q.message + \").\")) : void 0, d = c;\n            }\n\n            a[b] = d;\n            return a;\n          }, {}),\n          pathname: g,\n          route: a\n        };\n      })\n    };\n  }\n\n  void 0 === c && (c = \"\");\n  void 0 === d && (d = !1);\n  \"string\" === typeof b && (b = parsePath(b));\n  c = c.replace(/^\\/+|\\/+$/g, \"\");\n  var f = b.pathname.slice(1);\n  if (c) if (c === f) f = \"\";else if (f.startsWith(c)) f = f.slice(c.length).replace(/^\\/+/, \"\");else return null;\n  var g = N(a);\n  O(g);\n\n  for (a = 0; a < g.length; ++a) {\n    if (b = e(a), \"object\" === typeof b) return b.v;\n  }\n\n  return null;\n}\n\nfunction N(a, b, c, d, e) {\n  void 0 === b && (b = []);\n  void 0 === c && (c = \"\");\n  void 0 === d && (d = []);\n  void 0 === e && (e = []);\n  a.forEach(function (a, g) {\n    var f = K([c, a.path]),\n        H = d.concat(a);\n    g = e.concat(g);\n    b.push([f, H, g]);\n    a.children && N(a.children, b, f, H, g);\n  });\n  return b;\n}\n\nvar P = /^:\\w+$/,\n    R = 2,\n    S = 1,\n    T = 10,\n    U = -2;\n\nfunction V(a) {\n  return \"*\" === a;\n}\n\nfunction W(a) {\n  a = a.split(\"/\");\n  var b = a.length;\n  a.some(V) && (b += U);\n  return a.filter(function (a) {\n    return !V(a);\n  }).reduce(function (a, b) {\n    return a + (P.test(b) ? R : \"\" === b ? S : T);\n  }, b);\n}\n\nfunction O(a) {\n  var b = a.reduce(function (a, b) {\n    b = b[0];\n    a[b] = W(b);\n    return a;\n  }, {});\n  a.sort(function (a, d) {\n    var c = a[2];\n    a = b[a[0]];\n    var f = d[2];\n    d = b[d[0]];\n    return a !== d ? d - a : X(c, f);\n  });\n}\n\nfunction X(a, b) {\n  return a.length === b.length && a.slice(0, -1).every(function (a, d) {\n    return a === b[d];\n  }) ? a[a.length - 1] - b[b.length - 1] : 0;\n}\n\nfunction M(a, b, c) {\n  var d = [],\n      e = \"^(\" + a.replace(/^\\/+/, \"\").replace(/\\*\\//g, \"\").replace(/\\/?\\*?$/, \"\").replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\").replace(/:(\\w+)/g, function (a, b) {\n    d.push(b);\n    return \"([^\\\\/]+)\";\n  }) + \")\";\n  a.endsWith(\"*\") ? (a.endsWith(\"/*\") && (e += \"\\\\/?\"), d.push(\"*\"), e += \"(.*)\") : b && (e += \"\\\\/?\");\n  b && (e += \"$\");\n  return [new RegExp(e, c ? void 0 : \"i\"), d];\n}\n\nfunction K(a) {\n  return a.join(\"/\").replace(/\\/\\/+/g, \"/\");\n}\n\nfunction Y(a, b) {\n  var c = b.replace(/\\/+$/, \"\").replace(/\\/\\/+/g, \"/\").split(\"/\");\n  a.replace(/\\/\\/+/g, \"/\").split(\"/\").forEach(function (a) {\n    \"..\" === a ? 1 < c.length && c.pop() : \".\" !== a && c.push(a);\n  });\n  return 1 < c.length ? K(c) : \"/\";\n}\n\nfunction F(a, b) {\n  void 0 === b && (b = \"/\");\n  var c = \"string\" === typeof a ? parsePath(a) : a;\n  a = c.pathname;\n  var d = c.search;\n  d = void 0 === d ? \"\" : d;\n  c = c.hash;\n  c = void 0 === c ? \"\" : c;\n  return {\n    pathname: a ? a.startsWith(\"/\") ? Y(a, \"/\") : Y(a, b) : b,\n    search: d,\n    hash: c\n  };\n}\n\nfunction generatePath(a, b) {\n  void 0 === b && (b = {});\n  return a.replace(/:(\\w+)/g, function (a, d) {\n    return b[d] || \":\" + d;\n  }).replace(/\\*$/, function (a) {\n    return b[a] || a;\n  });\n}\n\n;\n\nfunction useBlocker(a, b) {\n  void 0 === b && (b = !0);\n  var c = React.useContext(n);\n  null == c ? \"production\" !== process.env.NODE_ENV ? l(!1, \"useBlocker() may be used only in the context of a <Router> component.\") : l(!1) : void 0;\n  var d = c.history;\n  React.useEffect(function () {\n    if (b) {\n      var c = d.block(function (b) {\n        var d = h({}, b, {\n          retry: function retry() {\n            c();\n            b.retry();\n          }\n        });\n        a(d);\n      });\n      return c;\n    }\n  }, [d, b, a]);\n}\n\n;\n\nfunction useHref(a) {\n  a = G(a);\n  var b = React.useContext(n);\n  null == b ? \"production\" !== process.env.NODE_ENV ? l(!1, \"useHref() may be used only in the context of a <Router> component.\") : l(!1) : void 0;\n  return b.history.createHref(a);\n}\n\n;\n\nfunction useMatch(a) {\n  var b = E();\n  a = G(a);\n  return b.pathname === a.pathname;\n}\n\n;\n\nfunction useParams() {\n  return React.useContext(p).params;\n}\n\n;\nexport { q as MemoryRouter, u as Navigate, w as Outlet, y as Route, r as Router, B as Routes, C as createRoutesFromChildren, generatePath, L as matchRoutes, F as resolveLocation, useBlocker, useHref, E as useLocation, useMatch, v as useNavigate, x as useOutlet, useParams, G as useResolvedLocation, D as useRoutes };","map":{"version":3,"sources":["../../packages/react-router/index.js"],"names":["readOnly","Object","obj","invariant","warning","cond","console","Error","LocationContext","React","RouteContext","outlet","params","pathname","route","MemoryRouter","children","initialEntries","initialIndex","timeout","historyRef","createMemoryHistory","history","PropTypes","search","hash","state","key","Navigate","to","replace","navigate","useNavigate","locationContext","Outlet","useOutlet","Route","element","path","startTransition","tx","useTransition","Router","location","setLocation","pending","timeoutMs","shouldListenRef","value","action","push","go","listen","block","Routes","basename","caseSensitive","routes","createRoutesFromChildren","useRoutes","childRoutes","useBlocker","when","autoUnblockingTx","retry","useHref","resolvedLocation","useResolvedLocation","useLocation","useMatch","activeRef","relativeTo","resolveLocation","method","useParams","missingTrailingSplatWarnings","warnAboutMissingTrailingSplatAt","message","parentParams","parentPathname","parentRoute","parentPath","joinPaths","matches","matchRoutes","parsePath","base","target","flattenedRoutes","flattenRoutes","rankFlattenedRoutes","i","flatRoutes","compilePath","matcher","index","r","keys","match","values","memo","safelyDecodeURIComponent","decodeURIComponent","error","parentRoutes","parentIndexes","indexes","paramRe","dynamicSegmentValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","s","computeScore","segments","initialScore","score","segment","pathScores","a","b","aIndexes","aScore","bIndexes","bScore","compareIndexes","n","siblings","pattern","_","end","undefined","paths","normalizeSlashes","resolvePathname","fromPathname","toPathname","relativeSegments","generatePath"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { createMemoryHistory, parsePath } from 'history';\n\nconst readOnly = __DEV__ ? obj => Object.freeze(obj) : obj => obj;\n\nfunction invariant(cond, message) {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONTEXT\n///////////////////////////////////////////////////////////////////////////////\n\nconst LocationContext = React.createContext(null);\n\nif (__DEV__) {\n  LocationContext.displayName = 'Location';\n}\n\nconst RouteContext = React.createContext({\n  outlet: null,\n  params: readOnly({}),\n  pathname: '',\n  route: null\n});\n\nif (__DEV__) {\n  RouteContext.displayName = 'Route';\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * A <Router> that stores all entries in memory.\n */\nexport function MemoryRouter({\n  children,\n  initialEntries,\n  initialIndex,\n  timeout\n}) {\n  let historyRef = React.useRef(null);\n\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  return (\n    <Router\n      children={children}\n      history={historyRef.current}\n      timeout={timeout}\n    />\n  );\n}\n\nif (__DEV__) {\n  MemoryRouter.displayName = 'MemoryRouter';\n  MemoryRouter.propTypes = {\n    children: PropTypes.node,\n    timeout: PropTypes.number,\n    initialEntries: PropTypes.arrayOf(\n      PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.shape({\n          pathname: PropTypes.string,\n          search: PropTypes.string,\n          hash: PropTypes.string,\n          state: PropTypes.object,\n          key: PropTypes.string\n        })\n      ])\n    ),\n    initialIndex: PropTypes.number\n  };\n}\n\n/**\n * Navigate programmatically using a component.\n */\nexport function Navigate({ to, replace, state }) {\n  let navigate = useNavigate();\n\n  let locationContext = React.useContext(LocationContext);\n  invariant(\n    locationContext != null,\n    // TODO: This error is probably because they somehow have\n    // 2 versions of the router loaded. We can help them understand\n    // how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !locationContext.history.static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  React.useEffect(() => {\n    navigate(to, { replace, state });\n  });\n\n  return null;\n}\n\nif (__DEV__) {\n  Navigate.displayName = 'Navigate';\n  Navigate.propTypes = {\n    to: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.shape({\n        pathname: PropTypes.string,\n        search: PropTypes.string,\n        hash: PropTypes.string\n      })\n    ]).isRequired,\n    replace: PropTypes.bool,\n    state: PropTypes.object\n  };\n}\n\n/**\n * Renders the child route's element, if there is one.\n */\nexport function Outlet() {\n  return useOutlet();\n}\n\nif (__DEV__) {\n  Outlet.displayName = 'Outlet';\n  Outlet.propTypes = {};\n}\n\n/**\n * Used in a route config to render an element.\n */\nexport function Route({ element = <Outlet /> }) {\n  return element;\n}\n\nif (__DEV__) {\n  Route.displayName = 'Route';\n  Route.propTypes = {\n    children: PropTypes.node,\n    element: PropTypes.element,\n    path: PropTypes.string\n  };\n}\n\n// TODO: Remove once React.useTransition is stable.\nconst startTransition = tx => tx();\nconst useTransition = React.useTransition || (() => [startTransition, false]);\n\n/**\n * The root context provider. There should be only one of these in a given app.\n */\nexport function Router({ children = null, history, timeout = 2000 }) {\n  let [location, setLocation] = React.useState(history.location);\n  let [startTransition, pending] = useTransition({ timeoutMs: timeout });\n  let shouldListenRef = React.useRef(true);\n\n  invariant(\n    !React.useContext(LocationContext),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You never need more than one.`\n  );\n\n  if (shouldListenRef.current) {\n    shouldListenRef.current = false;\n    history.listen(({ location }) => {\n      startTransition(() => {\n        setLocation(location);\n      });\n    });\n  }\n\n  return (\n    <LocationContext.Provider\n      children={children}\n      value={{ history, location, pending }}\n    />\n  );\n}\n\nif (__DEV__) {\n  Router.displayName = 'Router';\n  Router.propTypes = {\n    children: PropTypes.node,\n    history: PropTypes.shape({\n      action: PropTypes.string,\n      location: PropTypes.object,\n      push: PropTypes.func,\n      replace: PropTypes.func,\n      go: PropTypes.func,\n      listen: PropTypes.func,\n      block: PropTypes.func\n    }),\n    timeout: PropTypes.number\n  };\n}\n\n/**\n * A wrapper for useRoutes that treats its children as route and/or redirect\n * objects.\n */\nexport function Routes({ basename = '', caseSensitive = false, children }) {\n  let routes = createRoutesFromChildren(children);\n  return useRoutes(routes, basename, caseSensitive);\n}\n\nif (__DEV__) {\n  Routes.displayName = 'Routes';\n  Routes.propTypes = {\n    basename: PropTypes.string,\n    caseSensitive: PropTypes.bool,\n    children: PropTypes.node\n  };\n}\n\n/**\n * Utility function that creates a routes config object from a React\n * \"children\" object, which is usually either a React element or an\n * array of elements.\n */\nexport function createRoutesFromChildren(children) {\n  let routes = [];\n\n  React.Children.forEach(children, element => {\n    // Ignore non-elements. This allows people to more\n    // easily inline conditionals in their route config.\n    if (!React.isValidElement(element)) return;\n\n    let { children, path = '/' } = element.props;\n\n    // Transparently support React.Fragment and its children.\n    if (element.type === React.Fragment) {\n      routes.push.apply(routes, createRoutesFromChildren(children));\n      return;\n    }\n\n    let route = { path, element };\n    let childRoutes = createRoutesFromChildren(children);\n    if (childRoutes.length) {\n      route.children = childRoutes;\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Blocks all navigation attempts. This is useful for preventing the page from\n * changing until some condition is met, like saving form data.\n */\nexport function useBlocker(blocker, when = true) {\n  let locationContext = React.useContext(LocationContext);\n  invariant(\n    locationContext != null,\n    // TODO: This error is probably because they somehow have\n    // 2 versions of the router loaded. We can help them understand\n    // how to avoid that.\n    `useBlocker() may be used only in the context of a <Router> component.`\n  );\n  let { history } = locationContext;\n\n  React.useEffect(() => {\n    if (when) {\n      let unblock = history.block(tx => {\n        let autoUnblockingTx = {\n          ...tx,\n          retry() {\n            // Automatically unblock the transition so it can\n            // play all the way through before retrying it.\n            // TODO: Figure out how to re-enable this block if the\n            // transition is cancelled for some reason.\n            unblock();\n            tx.retry();\n          }\n        };\n\n        blocker(autoUnblockingTx);\n      });\n\n      return unblock;\n    }\n  }, [history, when, blocker]);\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n */\nexport function useHref(to) {\n  let resolvedLocation = useResolvedLocation(to);\n\n  let locationContext = React.useContext(LocationContext);\n  invariant(\n    locationContext != null,\n    // TODO: This error is probably because they somehow have\n    // 2 versions of the router loaded. We can help them understand\n    // how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  return locationContext.history.createHref(resolvedLocation);\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * NOTE: If you're using this it may mean you're doing some of your own \"routing\"\n * in your app, and we'd like to know what your use case is. We may be able to\n * provide something higher-level to better suit your needs.\n */\nexport function useLocation() {\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n */\nexport function useMatch(to) {\n  let location = useLocation();\n  let resolvedLocation = useResolvedLocation(to);\n  // TODO: Try to match search + hash as well\n  return location.pathname === resolvedLocation.pathname;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n */\nexport function useNavigate() {\n  let { pathname } = React.useContext(RouteContext);\n\n  let locationContext = React.useContext(LocationContext);\n  invariant(\n    locationContext != null,\n    // TODO: This error is probably because they somehow have\n    // 2 versions of the router loaded. We can help them understand\n    // how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n  let { history, pending } = locationContext;\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate = React.useCallback(\n    (to, { replace, state } = {}) => {\n      if (activeRef.current) {\n        if (typeof to === 'number') {\n          history.go(to);\n        } else {\n          let relativeTo = resolveLocation(to, pathname);\n          // If we are pending transition, use REPLACE instead of PUSH.\n          // This will prevent URLs that we started navigating to but\n          // never fully loaded from appearing in the history stack.\n          let method = !!replace || pending ? 'replace' : 'push';\n          history[method](relativeTo, state);\n        }\n      } else {\n        warning(\n          false,\n          `You should call navigate() in a useEffect, not when ` +\n            `your component is first rendered.`\n        );\n      }\n    },\n    [history, pathname, pending]\n  );\n\n  return navigate;\n}\n\n/**\n * Returns the outlet element at this level of the route hierarchy. Used to\n * render child routes.\n */\nexport function useOutlet() {\n  return React.useContext(RouteContext).outlet;\n}\n\n/**\n * Returns a hash of the dynamic params that were matched in the route path.\n * This is useful for using ids embedded in the URL to fetch data, but we\n * eventually want to provide something at a higher level for this.\n */\nexport function useParams() {\n  return React.useContext(RouteContext).params;\n}\n\n/**\n * Returns a fully-resolved location object relative to the current location.\n */\nexport function useResolvedLocation(to) {\n  let { pathname } = React.useContext(RouteContext);\n  return React.useMemo(() => resolveLocation(to, pathname), [to, pathname]);\n}\n\nlet missingTrailingSplatWarnings, warnAboutMissingTrailingSplatAt;\nif (__DEV__) {\n  missingTrailingSplatWarnings = {};\n  warnAboutMissingTrailingSplatAt = (pathname, cond, message) => {\n    if (!cond && !missingTrailingSplatWarnings[pathname]) {\n      missingTrailingSplatWarnings[pathname] = true;\n      warning(false, message);\n    }\n  };\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * Route objects may take one of 2 forms:\n *\n * - { path, element, children }\n * - { path, redirectTo }\n *\n * We should probably write this up in TypeScript instead of in a comment. In\n * fact, what am I even doing here. Nobody is ever going to read this.\n */\nexport function useRoutes(routes, basename = '', caseSensitive = false) {\n  let {\n    params: parentParams,\n    pathname: parentPathname,\n    route: parentRoute\n  } = React.useContext(RouteContext);\n\n  if (warnAboutMissingTrailingSplatAt) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since\n    // we cannot even give the warning unless they land at the parent route.\n    let parentPath = parentRoute && parentRoute.path;\n    warnAboutMissingTrailingSplatAt(\n      parentPathname,\n      !parentRoute || parentRoute.path.endsWith('*'),\n      `You rendered descendant <Routes> (or called \\`useRoutes\\`) at \"${parentPathname}\"` +\n        ` (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\".` +\n        ` This means if you navigate deeper, the parent won't match anymore and therefore` +\n        ` the child routes will never render.` +\n        `\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath}/*\">.`\n    );\n  }\n\n  basename = basename ? joinPaths([parentPathname, basename]) : parentPathname;\n\n  let location = useLocation();\n  let matches = React.useMemo(\n    () => matchRoutes(routes, location, basename, caseSensitive),\n    [routes, location, basename, caseSensitive]\n  );\n\n  if (!matches) {\n    // TODO: Warn about nothing matching, suggest using a catch-all route.\n    return null;\n  }\n\n  // TODO: Initiate preload sequence here.\n\n  // Otherwise render an element.\n  let element = matches.reduceRight((outlet, { params, pathname, route }) => {\n    return (\n      <RouteContext.Provider\n        children={route.element}\n        value={{\n          outlet,\n          params: readOnly({ ...parentParams, ...params }),\n          pathname: joinPaths([basename, pathname]),\n          route\n        }}\n      />\n    );\n  }, null);\n\n  return element;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Matches the given routes to a location and returns the match data.\n */\nexport function matchRoutes(\n  routes,\n  location,\n  basename = '',\n  caseSensitive = false\n) {\n  if (typeof location === 'string') {\n    location = parsePath(location);\n  }\n\n  // TODO: Validate location\n  // - it should have a pathname\n  let base = basename.replace(/^\\/+|\\/+$/g, '');\n  let target = location.pathname.slice(1);\n\n  if (base) {\n    if (base === target) {\n      target = '';\n    } else if (target.startsWith(base)) {\n      target = target.slice(base.length).replace(/^\\/+/, '');\n    } else {\n      return null;\n    }\n  }\n\n  let flattenedRoutes = flattenRoutes(routes);\n\n  // TODO: Validate the routes config\n  // - routes should all have paths and elements\n  // - redirects should have a redirectTo\n  // - redirects should not have children\n  // - warn about unreachable routes\n\n  rankFlattenedRoutes(flattenedRoutes);\n\n  for (let i = 0; i < flattenedRoutes.length; ++i) {\n    let [path, flatRoutes] = flattenedRoutes[i];\n\n    // TODO: Match on search, state too\n    let [matcher] = compilePath(path, /* end */ true, caseSensitive);\n\n    if (matcher.test(target)) {\n      return flatRoutes.map((route, index) => {\n        let routes = flatRoutes.slice(0, index + 1);\n        let path = joinPaths(routes.map(r => r.path));\n        let [matcher, keys] = compilePath(path, /* end */ false, caseSensitive);\n        let match = target.match(matcher);\n        let pathname = '/' + match[1];\n        let values = match.slice(2);\n        let params = keys.reduce((memo, key, index) => {\n          memo[key] = safelyDecodeURIComponent(values[index], key);\n          return memo;\n        }, {});\n\n        return { params, pathname, route };\n      });\n    }\n  }\n\n  return null;\n}\n\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value.replace(/\\+/g, ' '));\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (the error message was: ${error.message}).`\n    );\n\n    return value;\n  }\n}\n\nfunction flattenRoutes(\n  routes,\n  flattenedRoutes = [],\n  parentPath = '',\n  parentRoutes = [],\n  parentIndexes = []\n) {\n  routes.forEach((route, index) => {\n    let path = joinPaths([parentPath, route.path]);\n    let routes = parentRoutes.concat(route);\n    let indexes = parentIndexes.concat(index);\n\n    flattenedRoutes.push([path, routes, indexes]);\n\n    if (route.children) {\n      flattenRoutes(route.children, flattenedRoutes, path, routes, indexes);\n    }\n  });\n\n  return flattenedRoutes;\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === '*';\n\nfunction computeScore(path) {\n  let segments = path.split('/');\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  return segments\n    .filter(s => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === ''\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction rankFlattenedRoutes(flattenedRoutes) {\n  let pathScores = flattenedRoutes.reduce((memo, [path]) => {\n    memo[path] = computeScore(path);\n    return memo;\n  }, {});\n\n  flattenedRoutes.sort((a, b) => {\n    let [aPath, , aIndexes] = a;\n    let aScore = pathScores[aPath];\n\n    let [bPath, , bIndexes] = b;\n    let bScore = pathScores[bPath];\n\n    return aScore !== bScore\n      ? bScore - aScore // Higher score first\n      : compareIndexes(aIndexes, bIndexes);\n  });\n}\n\nfunction compareIndexes(a, b) {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? a[a.length - 1] - b[b.length - 1] // Earlier siblings come first\n    : 0; // It doesn't make sense to rank non-siblings by index, so they sort equal\n}\n\nfunction compilePath(path, end, caseSensitive) {\n  let keys = [];\n  let pattern =\n    '^(' +\n    path\n      .replace(/^\\/+/, '') // Ignore leading /\n      .replace(/\\*\\//g, '') // Ignore */ (from paths nested under a *)\n      .replace(/\\/?\\*?$/, '') // Ignore trailing /*, we'll handle it below\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, '\\\\$&') // Escape special regex chars\n      .replace(/:(\\w+)/g, (_, key) => {\n        keys.push(key);\n        return '([^\\\\/]+)';\n      }) +\n    ')';\n\n  if (path.endsWith('*')) {\n    if (path.endsWith('/*')) {\n      pattern += '\\\\/?'; // Don't include the / in params['*']\n    }\n    keys.push('*');\n    pattern += '(.*)';\n  } else if (end) {\n    pattern += '\\\\/?';\n  }\n\n  if (end) pattern += '$';\n\n  let flags = caseSensitive ? undefined : 'i';\n  let matcher = new RegExp(pattern, flags);\n\n  return [matcher, keys];\n}\n\nconst trimTrailingSlashes = path => path.replace(/\\/+$/, '');\nconst normalizeSlashes = path => path.replace(/\\/\\/+/g, '/');\nconst joinPaths = paths => normalizeSlashes(paths.join('/'));\nconst splitPath = path => normalizeSlashes(path).split('/');\n\nfunction resolvePathname(toPathname, fromPathname) {\n  let segments = splitPath(trimTrailingSlashes(fromPathname));\n  let relativeSegments = splitPath(toPathname);\n\n  relativeSegments.forEach(segment => {\n    if (segment === '..') {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== '.') {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? joinPaths(segments) : '/';\n}\n\n/**\n * Returns a fully resolve location object relative to the given pathname.\n */\nexport function resolveLocation(to, fromPathname = '/') {\n  let { pathname: toPathname, search = '', hash = '' } =\n    typeof to === 'string' ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith('/')\n      ? resolvePathname(toPathname, '/')\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return { pathname, search, hash };\n}\n\n/**\n * Creates a path with params interpolated.\n */\nexport function generatePath(pathname, params = {}) {\n  return pathname\n    .replace(/:(\\w+)/g, (_, key) => params[key] || `:${key}`)\n    .replace(/\\*$/, splat => params[splat] || splat);\n}\n"]},"metadata":{},"sourceType":"module"}